// SPDX-License-Identifier: GPL-3.0-or-later

pragma solidity ^0.8.4;

// a library for performing various math operations

import "@openzeppelin/contracts/utils/math/Math.sol";

library GayMath {
    using Math for uint256;

    uint256 private constant EXP_SCALE = 1e18;
    uint256 private constant HALF_EXP_SCALE = EXP_SCALE / 2;

    function getExp(uint256 num, uint256 denom)
        internal
        pure
        returns (uint256)
    {
        (bool successMul, uint256 scaledNumber) = num.tryMul(EXP_SCALE);
        if (!successMul) return 0;
        (bool successDiv, uint256 rational) = scaledNumber.tryDiv(denom);
        if (!successDiv) return 0;
        return rational;
    }

    function mulExp(uint256 a, uint256 b) internal pure returns (uint256) {
        (bool successMul, uint256 doubleScaledProduct) = a.tryMul(b);
        if (!successMul) return 0;
        (
            bool successAdd,
            uint256 doubleScaledProductWithHalfScale
        ) = HALF_EXP_SCALE.tryAdd(doubleScaledProduct);
        if (!successAdd) return 0;
        (bool successDiv, uint256 product) = doubleScaledProductWithHalfScale
            .tryDiv(EXP_SCALE);
        assert(successDiv == true);
        return product;
    }

    function percentage(uint256 _num, uint256 _percentage)
        internal
        pure
        returns (uint256)
    {
        uint256 rational = getExp(_num, 5);
        return mulExp(rational, _percentage);
    }

    function min(uint256 x, uint256 y) internal pure returns (uint256 z) {
        z = x < y ? x : y;
    }

    // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)
    function sqrt(uint256 y) internal pure returns (uint256 z) {
        if (y > 3) {
            z = y;
            uint256 x = y / 2 + 1;
            while (x < z) {
                z = x;
                x = (y / x + x) / 2;
            }
        } else if (y != 0) {
            z = 1;
        }
    }
}
